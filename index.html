<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<script src="phaser.min.js"></script>
<script src="objets.json"></script>
<script src="recette.json"></script>
<script language="javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'MasterChef v1', { preload: preload, create: create });

function preload() {

	Object.values(scene).forEach(function (o) {
		if (o.image)
		game.load.spritesheet(o.nom, o.image.src, o.image.dimX, o.image.dimY, o.image.clés);
		
	});
}

var ingredients;
var scene, interactions;

function create() {

	game.stage.backgroundColor = "#dedede";

	//Création de l'index principal pour permettre de retrouver facilement
	//les interactions attachées à un objet (source)
	interactions = {};
	recette.forEach(function(interaction) {
		var obj = interaction.preconditions.source.obj;
		var libétats = interaction.preconditions.source.état;
		//Il peut y avoir un ou plusieurs états initiaux
		//Je simplifie en regroupant les 2 cas.
		if (!(libétats instanceof Array)) libétats = [ libétats ];
		libétats.forEach(function(libétat) {
			var état = scene[obj].états.indexOf(libétat);
			if (!(obj in interactions)) {
				interactions[obj] = {};
				interactions[obj][état] = [];
				interactions[obj][état].push(interaction);
			} else {
				if (!(état in interactions[obj])) {
					interactions[obj][état] = [];
					interactions[obj][état].push(interaction);
				} else {
					interactions[obj][état].push(interaction);
				}
			}
		});
	});

	//Création des objets dans la scène
	//Affectation du comportement drag&drop
	//Référencement des sprites dans la scene
	ingredients = game.add.group();
	Object.keys(scene).forEach(function(key) {
		var objet = scene[key];
		ingredient = ingredients.create(objet.x, objet.y, objet.nom, objet.état);
		objet.sprite = ingredient;
		ingredient.anchor.setTo(0.5,1);
		game.physics.enable(ingredient, Phaser.Physics.ARCADE);
		if (interactions[objet.nom]) {
			ingredient.inputEnabled = true;
			ingredient.input.enableDrag(true);
		}
		ingredient.events.onDragStart.add(function(obj) {
			obj.bringToTop();
			obj.retourne = function() {
				game.add.tween(obj).to(
					{ x:objet.x, y:objet.y}, 
					1000, 
					Phaser.Easing.Circular.Out,
					true
				);
			}
		});
		ingredient.events.onDragStop.add(function(obj) {
			if (!game.physics.arcade.overlap(obj, ingredients, interaction)) {
				obj.retourne();
			}
		});
	});
}


function interaction(me, other) {
	//Je veux trouver rapidement les interactions dont me.key est la source.
	//Je dois disposer d'un index, qui est construit lors du parsing de la recette.
	var interactionsDisponibles = interactions[me.key][me.frame];
	if (interactionsDisponibles) {
		interactionsDisponibles.forEach(function(inter) {
			//Pour chaque interaction disponible pour cette source dans cet état
			//Je cherche si l'objet cible dans son état est une cible de l'interaction
			var ciblePossible = inter.preconditions.cible.obj;
			var ciblePossibleEtat = inter.preconditions.cible.état;
			//objet actuellement ciblé par l'interaction
			var cibleActuelle = other.key;
			var cibleActuelleEtat = scene[other.key].états[other.frame];
			var interactionPossible = false;
			if (ciblePossibleEtat instanceof Array) {
				//Cas de l'interaction dans plusieurs états
				if (
					ciblePossibleEtat.indexOf(cibleActuelleEtat)!=-1 && 
					cibleActuelle==ciblePossible
				) interactionPossible = true;
			} else {
				//Cas de l'interaction à un seul état
				if (
					ciblePossibleEtat==cibleActuelleEtat &&
					ciblePossible==cibleActuelle
				) interactionPossible = true;
			}
			if (interactionPossible) {
				//Application des postconditions
				inter.postconditions.forEach(function(postc) {
					var obj = postc.obj;
					var nouvelEtat = scene[postc.obj].états.indexOf(postc.état);
					scene[obj].état = nouvelEtat;
					scene[obj].sprite.frame = nouvelEtat;
				});
				console.log(scene);
				return; //car a priori l'interaction est unique, donc pas la peine de continuer
			}
		});
	}
	me.retourne();
}
</script>
</html>
